<html>
	<head>

		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
		<link rel="stylesheet" type="text/css" href="/css/bootstrap.css">
		<link rel="stylesheet" type="text/css" href="/css/BootstrapXL.css">
		<link rel="stylesheet" type="text/css" href="../../../style.css">
	
	<title>Balls On A Board</title>

	</head>
	
	

<body>
	
		<!-- Navbar -->
		<div class="top">
			<nav>
				<div class="bar card">
					
					<a class="bar-item  button  padding-large  hide-medium  hide-large  right" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
				
					<a href="#About" 															class="bar-item button padding-large">Luke Gatehouse</a>
					<a href="../../../index.html" 												class="bar-item button padding-large">Home</a>
					<a href="../../Uni.html" 														class="bar-item button padding-large hide-small">Uni Work</a>
				</div>
			</nav>
		</div>


		<!-- Navbar on small screens (remove the onclick attribute if you want the navbar to always show on top of the content when clicking on the links) -->
		<div id="navDemo" class="bar-block hide hide-large hide-medium top" style="margin-top:46px">
			<a href="../../../index.html" 														class="bar-item button padding-large" onclick="myFunction()">Home</a>
			<a href="../../Uni.html" 																class="bar-item button padding-large" onclick="myFunction()">Uni Work</a>
			
		</div>
		
		
	<div class="page" id="About" style="display:block; margin-top:80px;">
		<div align="center" style="margin-left:5%; margin-right:5%;">
			
			<div class="section-content" style="display: table-cell; vertical-align: middle;">
				<span class="title--med title">Balls On A Board</span>
			</div>
			
			<table style="margin: auto;">
				<tbody>
					<tr>
						<td>
							<strong><a> Project Type: </a></strong>
						</td>
						<td>
							<a> University </a>
						</td>
					</tr>
					<tr>
						<td>
							<strong><a> Software/Engine:  </a></strong>
						</td>
						<td>
							<a> TL-Engine </a>
						</td>
					</tr>
					<tr>
						<td>
							<strong><a> Language:  </a></strong>
						</td>
						<td>
							<a> C++ </a>
						</td>
					</tr>
				</tbody>
			</table>
			
			
			<div class="section-desc">
				<span class="text">
					<p>
						The link directly below will take you to my GitHub repositories for the current work displayed. Beware most univeristy work will not currently be shown due to that im still in university and dont want anyone using my work as their own, thefore plagurism would be an issue, this will be changed when univeristy has been completed or finished to display all work.
					</p>
			
					<p align="center">
						<a href="https://github.com/LPG-GamesDev/uni-Year-1-CO1301-Games-Concept-" target="_blank"> https://github.com/LPG-GamesDev/uni-Year-1-CO1301-Games-Concept- </a>
					</p>
				</span>
			</div>
				

			
					
			<section id="Video-Offset-Section">
				<section id="Video-Section">
					<video playsinline autoplay muted loop class="Video" width="90%" >
						<source src="../../VIDEO/TestVideo.mp4" type="video/mp4">
					</video>
				</section>
			</section>
			
			
			
			<button class="accordion">Description</button>
				<div class="panel">
					<p> ENTER DESCRIPTION </p>
					
					
				</div>
				
			<button class="accordion">Brief</button>
				<div class="panel">
					<embed src="" width="1100px" height="800px">
				</div>
				
			<button class="accordion">Code</button>
				<div class="panel">
					<pre>
						<code>
						
// balls on a board.cpp: A program using the TL-Engine

#include &lt;TL-Engine.h&gt;	// TL-Engine include file and namespace
using namespace tle;

void main()
{
	// Create a 3D engine (using TLX engine here) and open a window for it
	I3DEngine* myEngine = New3DEngine(kTLX);
	myEngine-&gt;StartWindowed();

	// Add default folder for meshes and other media
	myEngine-&gt;AddMediaFolder(&quot;S:\\TL-Engine\\Media&quot;);

	// CAMERA SETUP
	ICamera* MyCamera;
	MyCamera = myEngine-&gt;CreateCamera(kManual);
	MyCamera-&gt;SetPosition(0.0f, 240.0f, -240.0f);
	MyCamera-&gt;RotateLocalX(45.0f);

	// MESHES AND MODELS USED
	IMesh* FloorMesh = myEngine-&gt;LoadMesh(&quot;Floor.x&quot;);
	IModel* Floor = FloorMesh-&gt;CreateModel(0.0f, -0.2f, 0.0f);

	IMesh* BoardMesh = myEngine-&gt;LoadMesh(&quot;Board.x&quot;);
	IModel* Board = BoardMesh-&gt;CreateModel(0.0f, 0.0f, 0.0f);

	IMesh* Ball_1Mesh = myEngine-&gt;LoadMesh(&quot;Ball.x&quot;);
	IModel* Ball_1 = Ball_1Mesh-&gt;CreateModel(125.0f, 10.0f, -125.0f);
	Ball_1-&gt;SetSkin(&quot;violet.png&quot;);

	IMesh* Ball_2Mesh = myEngine-&gt;LoadMesh(&quot;Ball.x&quot;);
	IModel* Ball_2 = Ball_2Mesh-&gt;CreateModel(-125.0f, 10.0f, 75.0f);
	Ball_2-&gt;SetSkin(&quot;blue.png&quot;);

	IMesh* Ball_3Mesh = myEngine-&gt;LoadMesh(&quot;Ball.x&quot;);
	IModel* Ball_3 = Ball_3Mesh-&gt;CreateModel(-125.0f, 10.0f, -125.0f);
	Ball_3-&gt;SetSkin(&quot;green.png&quot;);

	IMesh* Ball_4Mesh = myEngine-&gt;LoadMesh(&quot;Ball.x&quot;);
	IModel* Ball_4 = Ball_4Mesh-&gt;CreateModel(125.0f, 10.0f, 75.0f);
	Ball_4-&gt;SetSkin(&quot;indigo.png&quot;);

	// ENUMS,FLOATS AND VARIABLES
	enum EDirection { Up, Down, Left, Right };
	EDirection Ball_1_Direction = Left;
	EDirection Ball_2_Direction = Right;
	EDirection Ball_3_Direction = Up;
	EDirection Ball_4_Direction = Down;

	enum EBallState { Not_Moving, Moving };
	EBallState Ball_1_State = Moving;
	EBallState Ball_2_State = Not_Moving;
	EBallState Ball_3_State = Not_Moving;
	EBallState Ball_4_State = Moving;

	enum EBallHeightState { Grounded, Moving_Down, Moving_Up, Raised };
	EBallHeightState Height_State = Grounded;

	enum EBall_Colour { Violet, Green, Blue, Indigo };
	EBall_Colour Ball_1_colour = Violet;
	EBall_Colour Ball_2_colour = Blue;
	EBall_Colour Ball_3_colour = Green;
	EBall_Colour Ball_4_colour = Indigo;

	const float kGameSpeed = 0.10f;
	float SphereSpeed = 1.0f;

	float MaxSpeed = kGameSpeed * 5;
	float MinSpeed = kGameSpeed / 2;

	const float kTurningPoint_1 = 125.0f;
	const float kTurningPoint_2 = 75.0f;
	const float kTurningPoint_3 = 40.0f;
	const float kTurningPoint_4 = 10.0f;

	const float kGamePause = 0.0f;
	bool PauseGame = false;

	float MouseWheelResult = 0.0f;


	// The main game loop, repeat until engine is stopped
	while (myEngine-&gt;IsRunning())
	{
		// Draw the scene
		myEngine-&gt;DrawScene();

		/**** Update your scene each frame here ****/

		// PAUSES GAME AND STOPS BALLS FROM MOVING UP,DOWN OR IN A SQUARE
		if (myEngine-&gt;KeyHit(Key_P))
		{
			if (PauseGame == false)
			{
				PauseGame = true;
			}
			else if (PauseGame == true)
			{
				Ball_1-&gt;MoveX(kGamePause);
				Ball_1-&gt;MoveZ(kGamePause);
				Ball_2-&gt;MoveX(kGamePause);
				Ball_2-&gt;MoveZ(kGamePause);
				Ball_3-&gt;MoveX(kGamePause);
				Ball_3-&gt;MoveZ(kGamePause);
				Ball_4-&gt;MoveX(kGamePause);
				Ball_4-&gt;MoveZ(kGamePause);
				PauseGame = false;
			}
		}

		if (PauseGame == false)
		{

			// MOUSEWHEELRESULT RECORDS THE RESULT OF &quot;GETMOUSEWHEELMOVEMENT&quot; DUE TO NOT BEING ABLE TO RECORD MULTIPLE INSTANCES OF SCROLLING THE WHEEL
			// MOUSEWHEELRESULT WATCHES FOR CHANGES OF THE MOUSE WHEEL (INCREASE/DECREASE)
			// ONCE INCREASED OR DECREASED IT WILL ONLY EVER GO TO ITS MAXIMUM OR MINIMUM SPEED
			MouseWheelResult = myEngine-&gt;GetMouseWheelMovement();
			if (MouseWheelResult &lt; 0.0f)
			{
				SphereSpeed -= kGameSpeed / 10.0f;
				if (SphereSpeed &lt;= MinSpeed)
				{
					SphereSpeed = MinSpeed;
				}
			}
			else if (MouseWheelResult &gt; 0.0f)
			{
				SphereSpeed += kGameSpeed / 10.0f;
				if (SphereSpeed &gt;= MaxSpeed)
				{
					SphereSpeed = MaxSpeed;
				}
			}

			// CHECKS BALL STATE (MOVING / NOT_MOVING)
			// CHECKS BALL DIRECTION
			// MOVES BALL UNTIL DESTINATION
			// CHANGES BALL TO NEXT DIRECTION
			// STOPS ROTATION IF BALL ISNT GROUNDED
			// CHANGES DIRECTION FOR NEXT INSTANCE
			if (Ball_1_State == Moving)
			{
				if (Ball_1_Direction == Left)
				{
					Ball_1-&gt;MoveX(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_1-&gt;RotateZ(kGameSpeed * SphereSpeed);
					if (Ball_1-&gt;GetX() &lt;= -kTurningPoint_2)
					{
						Ball_1_Direction = Up;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_1_Direction == Up)
				{
					Ball_1-&gt;MoveZ(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_1-&gt;RotateX(kGameSpeed * SphereSpeed);
					if (Ball_1-&gt;GetZ() &gt;= kTurningPoint_2)
					{
						Ball_1_Direction = Right;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_1_Direction == Right)
				{
					Ball_1-&gt;MoveX(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_1-&gt;RotateZ(-kGameSpeed * SphereSpeed);
					if (Ball_1-&gt;GetX() &gt;= kTurningPoint_1)
					{
						Ball_1_Direction = Down;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_1_Direction == Down)
				{
					Ball_1-&gt;MoveZ(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_1-&gt;RotateX(-kGameSpeed * SphereSpeed);
					if (Ball_1-&gt;GetZ() &lt;= -kTurningPoint_1)
					{
						Ball_1_Direction = Left;
						Ball_1_State = Not_Moving;
						Ball_4_State = Not_Moving;
						Ball_2_State = Moving;
						Ball_3_State = Moving;
					}
				}
			}


			// CHECKS BALL STATE (MOVING / NOT_MOVING)
			// CHECKS BALL DIRECTION
			// MOVES BALL UNTIL DESTINATION
			// CHANGES BALL TO NEXT DIRECTION
			// STOPS ROTATION IF BALL ISNT GROUNDED
			// CHANGES DIRECTION FOR NEXT INSTANCE
			if (Ball_2_State == Moving)
			{
				if (Ball_2_Direction == Right)
				{
					Ball_2-&gt;MoveX(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_2-&gt;RotateZ(-kGameSpeed * SphereSpeed);
					if (Ball_2-&gt;GetX() &gt;= kTurningPoint_2)
					{
						Ball_2_Direction = Down;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_2_Direction == Down)
				{
					Ball_2-&gt;MoveZ(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_2-&gt;RotateX(-kGameSpeed * SphereSpeed);
					if (Ball_2-&gt;GetZ() &lt;= -kTurningPoint_1)
					{
						Ball_2_Direction = Left;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_2_Direction == Left)
				{
					Ball_2-&gt;MoveX(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_2-&gt;RotateZ(kGameSpeed * SphereSpeed);
					if (Ball_2-&gt;GetX() &lt;= -kTurningPoint_1)
					{
						Ball_2_Direction = Up;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_2_Direction == Up)
				{
					Ball_2-&gt;MoveZ(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_2-&gt;RotateX(kGameSpeed * SphereSpeed);
					if (Ball_2-&gt;GetZ() &gt;= kTurningPoint_2)
					{
						Ball_2_Direction = Right;
						Ball_2_State = Not_Moving;
						Ball_3_State = Not_Moving;
						Ball_1_State = Moving;
						Ball_4_State = Moving;
					}
				}
			}

			// CHECKS BALL STATE (MOVING / NOT_MOVING)
			// CHECKS BALL DIRECTION
			// MOVES BALL UNTIL DESTINATION
			// CHANGES BALL TO NEXT DIRECTION
			// STOPS ROTATION IF BALL ISNT GROUNDED
			// CHANGES DIRECTION FOR NEXT INSTANCE
			if (Ball_3_State == Moving)
			{

				if (Ball_3_Direction == Up)
				{
					Ball_3-&gt;MoveZ(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_3-&gt;RotateX(kGameSpeed * SphereSpeed);
					if (Ball_3-&gt;GetZ() &gt;= kTurningPoint_2)
					{
						Ball_3_Direction = Right;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_3_Direction == Right)
				{
					Ball_3-&gt;MoveX(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_3-&gt;RotateZ(-kGameSpeed * SphereSpeed);
					if (Ball_3-&gt;GetX() &gt;= kTurningPoint_2)
					{
						Ball_3_Direction = Down;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_3_Direction == Down)
				{
					Ball_3-&gt;MoveZ(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_3-&gt;RotateX(-kGameSpeed * SphereSpeed);
					if (Ball_3-&gt;GetZ() &lt;= -kTurningPoint_1)
					{
						Ball_3_Direction = Left;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_3_Direction == Left)
				{
					Ball_3-&gt;MoveX(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_3-&gt;RotateZ(kGameSpeed * SphereSpeed);
					if (Ball_3-&gt;GetX() &lt;= -kTurningPoint_1)
					{
						Ball_3_Direction = Up;
					}
				}
			}

			// CHECKS BALL STATE (MOVING / NOT_MOVING)
			// CHECKS BALL DIRECTION
			// MOVES BALL UNTIL DESTINATION
			// CHANGES BALL TO NEXT DIRECTION
			// STOPS ROTATION IF BALL ISNT GROUNDED
			// CHANGES DIRECTION FOR NEXT INSTANCE
			if (Ball_4_State == Moving)
			{

				if (Ball_4_Direction == Down)
				{
					Ball_4-&gt;MoveZ(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_4-&gt;RotateX(-kGameSpeed * SphereSpeed);
					if (Ball_4-&gt;GetZ() &lt;= -kTurningPoint_1)
					{
						Ball_4_Direction = Left;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_4_Direction == Left)
				{
					Ball_4-&gt;MoveX(-kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_4-&gt;RotateZ(kGameSpeed * SphereSpeed);
					if (Ball_4-&gt;GetX() &lt;= -kTurningPoint_2)
					{
						Ball_4_Direction = Up;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_4_Direction == Up)
				{
					Ball_4-&gt;MoveZ(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_4-&gt;RotateX(kGameSpeed * SphereSpeed);
					if (Ball_4-&gt;GetZ() &gt;= kTurningPoint_2)
					{
						Ball_4_Direction = Right;
					}
				}

				// CHECKS BALL STATE (MOVING / NOT_MOVING)
				// CHECKS BALL DIRECTION
				// MOVES BALL UNTIL DESTINATION
				// CHANGES BALL TO NEXT DIRECTION
				// STOPS ROTATION IF BALL ISNT GROUNDED
				// CHANGES DIRECTION FOR NEXT INSTANCE
				if (Ball_4_Direction == Right)
				{
					Ball_4-&gt;MoveX(kGameSpeed * SphereSpeed);
					if (Height_State == Grounded)Ball_4-&gt;RotateZ(-kGameSpeed * SphereSpeed);
					if (Ball_4-&gt;GetX() &gt;= kTurningPoint_1)
					{
						Ball_4_Direction = Down;
					}
				}
			}

			// HEIGHT_STATE IS SET TO GROUNDED STANDARD (THE BALLS ARE ON THE GROUND)
			// WHEN &quot;KEY_UP&quot; IS PRESSED THIS CHANGES THE HEIGHT_STATE
			if (Height_State == Grounded)
			{
				if (myEngine-&gt;KeyHit(Key_Up))
				{
					Height_State = Moving_Up;
				}
			}

			// AFTER THE HEIGHT_STATE HAS CHANGED TO MOVING_UP THE 4 BALLS ARE RAISED
			// 1 OF THE BALLS IS CHECKED SO IT STOPS WHEN IT REACHS 30 UNITS HIGHER THAN ITS STARTING POSITION
			// AFTER REACHING ITS MAXIUM HEIGHT OF 40 UNITS TOTAL THE HEIGHT_STATE IS CHANGED TO RAISED
			if (Height_State == Moving_Up)
			{
				Ball_1-&gt;MoveY(kGameSpeed * SphereSpeed);
				Ball_2-&gt;MoveY(kGameSpeed * SphereSpeed);
				Ball_3-&gt;MoveY(kGameSpeed * SphereSpeed);
				Ball_4-&gt;MoveY(kGameSpeed * SphereSpeed);
				if (Ball_1-&gt;GetY() &gt;= kTurningPoint_3)
				{
					Height_State = Raised;
				}
			}

			// CHECKS HEIGHT_STATE
			// CHANGES THE HEIGHT_STATE AFTER &quot;KEY_DOWN&quot; IS PRESSED
			if (Height_State == Raised)
			{
				if (myEngine-&gt;KeyHit(Key_Down))
				{
					Height_State = Moving_Down;
				}
			}

			// AFTER THE HEIGHT_STATE HAS CHANGED TO MOVING_DOWN THE 4 BALLS ARE MOVED DOWN TO THEIR STARTING POSITION
			// 1 BALL IS CHECKED SO IT STOPS WHEN IT REACHES ITS LOWEST UNIT (10.0F)
			// AFTER REACHING ITS ORIGINAL POSTION THE HEIGHT_STATE IS CHANGED BACK TO GROUNDED
			if (Height_State == Moving_Down)
			{
				Ball_1-&gt;MoveY(-kGameSpeed * SphereSpeed);
				Ball_2-&gt;MoveY(-kGameSpeed * SphereSpeed);
				Ball_3-&gt;MoveY(-kGameSpeed * SphereSpeed);
				Ball_4-&gt;MoveY(-kGameSpeed * SphereSpeed);
				if (Ball_1-&gt;GetY() &lt;= kTurningPoint_4)
				{
					Height_State = Grounded;
				}
			}

			//BALL COLOUR CYCLE
			if (Ball_1_colour == Violet &amp;&amp; Ball_2_colour == Blue &amp;&amp; Ball_3_colour == Green &amp;&amp; Ball_4_colour == Indigo)
			{
				if (myEngine-&gt;KeyHit(Key_E))
				{
					Ball_1_colour = Indigo;
					Ball_1-&gt;SetSkin(&quot;indigo.png&quot;);

					Ball_2_colour = Green;
					Ball_2-&gt;SetSkin(&quot;green.png&quot;);

					Ball_3_colour = Violet;
					Ball_3-&gt;SetSkin(&quot;violet.png&quot;);

					Ball_4_colour = Blue;
					Ball_4-&gt;SetSkin(&quot;blue.png&quot;);
				}
			}

			if (Ball_1_colour == Indigo &amp;&amp; Ball_2_colour == Green &amp;&amp; Ball_3_colour == Violet &amp;&amp; Ball_4_colour == Blue)
			{
				if (myEngine-&gt;KeyHit(Key_E))
				{
					Ball_1_colour = Blue;
					Ball_1-&gt;SetSkin(&quot;blue.png&quot;);

					Ball_2_colour = Violet;
					Ball_2-&gt;SetSkin(&quot;violet.png&quot;);

					Ball_3_colour = Indigo;
					Ball_3-&gt;SetSkin(&quot;indigo.png&quot;);

					Ball_4_colour = Green;
					Ball_4-&gt;SetSkin(&quot;green.png&quot;);
				}
			}

			if (Ball_1_colour == Blue &amp;&amp; Ball_2_colour == Violet &amp;&amp; Ball_3_colour == Indigo &amp;&amp; Ball_4_colour == Green)
			{
				if (myEngine-&gt;KeyHit(Key_E))
				{
					Ball_1_colour = Green;
					Ball_1-&gt;SetSkin(&quot;green.png&quot;);

					Ball_2_colour = Indigo;
					Ball_2-&gt;SetSkin(&quot;indigo.png&quot;);

					Ball_3_colour = Blue;
					Ball_3-&gt;SetSkin(&quot;blue.png&quot;);

					Ball_4_colour = Violet;
					Ball_4-&gt;SetSkin(&quot;violet.png&quot;);
				}
			}

			if (Ball_1_colour == Green &amp;&amp; Ball_2_colour == Indigo &amp;&amp; Ball_3_colour == Blue &amp;&amp; Ball_4_colour == Violet)
			{
				if (myEngine-&gt;KeyHit(Key_E))
				{
					Ball_1_colour = Violet;
					Ball_1-&gt;SetSkin(&quot;violet.png&quot;);

					Ball_2_colour = Blue;
					Ball_2-&gt;SetSkin(&quot;blue.png&quot;);

					Ball_3_colour = Green;
					Ball_3-&gt;SetSkin(&quot;green.png&quot;);

					Ball_4_colour = Indigo;
					Ball_4-&gt;SetSkin(&quot;indigo.png&quot;);
				}
			}
		}

		// EXIT
		if (myEngine-&gt;KeyHit(Key_Escape))
		{
			myEngine-&gt;Stop();
		}
	}

	// Delete the 3D engine now we are finished with it
	myEngine-&gt;Delete();
}
						
						</code>
					</pre>
				</div>
				
		</div>
	</div>













		<!-- CONTACT -->
		<section id="Contact-Offset-Section" style="background-color: rgba(100,0,0,1)">
			<section class="title">
				<h1 align="center"> CONTACT ME </h1>
			</section>
				<section id="Contact-Text-Section">
					<span class="text">
						<p align="center"> 
							Feel free to send me an Email at:
							<a href="mailto:lpg.gamesdev@gmail.com" target="_blank">lpg.gamesdev@gmail.com</a><br>
							I'll respond as soon as I'm able. <br>
							
							<br>
							
							<a href="https://www.linkedin.com/in/luke-gatehouse/" target="_blank">LinkedIn</a>
							
							 | 
							
							<a href="https://github.com/LPG-GamesDev" target="_blank">Github</a>
						</p>
						
					</span>
				</section>
		</section>

		
		<!-- Spacer -->
		<section id="spacer">
		</section>
		
		
		
<script>
	function myFunction() 
	{
		var x = document.getElementById("navDemo");
		
	if (x.className.indexOf("show") == -1) 
		{
			x.className += " show";
		} 
	else 
		{ 
			x.className = x.className.replace(" show", "");
		}
	}
</script>


<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.maxHeight) {
      panel.style.maxHeight = null;
    } else {
      panel.style.maxHeight = panel.scrollHeight + "px";
    } 
  });
}
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

	</body>
</html>